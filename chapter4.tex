\chapter{Shared spaces}\label{ch:4}
\label{sec:shared_space}

Shared address space between the hypervisor and the guest is used for implementing the VMM logic of translations during adaptive binary translations. Two different types of shared space are required for performing adaptive binary translation. One is used to store the emulated state of the guest as maintained by the hypervisor. All privileged opcodes that are being patched i.e mfmsr,mfspr, mtspr, mtspr, wrtee (for details please see Table~\ref{tab:priv_opcodes}) in general are trying to modify the guest execution state. Such instructions are accessing or modifying some privilege register maintained by the hypervisor. This memory region is used to store all such emulated registers to maintain the guest emulated state and is shared between the guest and the hypervisor. All privilege instructions are patched with translation code to modify these emulated state registers directly from the shared space thus saving VM exits. These translations may be single line or multi-line in nature as discussed in Section~\ref{adaptive_binary_translation}. The other shared address space called translation cache comes into action while implementing such multi-line translations. Translation cache contains the emulation code for translations requiring multi-line instructions to implement the VMM logic. Also this shared space also has constraints that it should lie within $\pm$32MB of the patch-site.

\section{Setup}
\label{setup_space}
As discussed in Section~\ref{adaptive_binary_translation} the shared space sharing the guest emulated state is constrained to be either in top or bottom 32KB of the guest's address space if single line translations are allowed. In Linux we use the top address space of the guest to map this address space. To make sure that this address space is not being used we keep track of the guest tlb entries mapping the guest address space. If any guest tlb entry is found to map this region then single line translations are removed and the emulated guest's state will be stored at any another unmapped guest's region and can be accessed using multi-line translation. If no such unmapped region is found then the binary-optimizations are not done.

Translation cache is required to store the translations for multi-line patching and is constrained to be within $\pm$32MB of all such patch-site. In practice we needed a translation cache of as small as 32KB for containing all the multi-line translations. To met these requirements we steal some region from the guest address space to create space for the translation cache. The stolen space from the guest's address space must belong to a data section since any branch or in-between jump to translation cache by the guest without our knowledge will result in an unexpected behavior. Thus a region belonging to a data section will be sure not to have such jumps and in-between branches. The kernel’s read-only, read-write data, and bss sections are examples of such data sections. If a 32KB or larger data region is available within ±32MB of the patch-site, we steal 32KB from this region and copy it to the host, and use this region’s space to store the translation cache(see Figure~\ref{translation_cache_stealing}). This region is then marked execute-only so that all original accesses to this region now trap into the hypervisor and emulated correctly. This presents us a mechanism to dynamically allocate the translation cache without guest's knowledge while ensuring the guest's correctness.

Stealing a region from a data section increases the tracing page faults on this stolen region which further deteriorates our optimization performance since the data section can be heavily accessed region and every such access is trapped and needs to be emulated. These tracing page faults can degrade the performce results due to binary optimizations and need to be optimized. We discuss our optimization to reduce these tracing page fualts in Section~\ref{tcache_optimizations}. 

The other way of acquiring translation cache is to get it allocated by the guest and the guest will inform the host using a hypercall mechanism. This requires static changes in the guest kernel similar to para-virtual extensions and thus are not used.




