\chapter{Introduction}\label{ch:1}
Embedded devices based on Power Architecture processors are dominant for their favourable power/performance characteristics. Virtualization on these platforms is compelling for several applications including high availability (active/standby configuration without additional hardware), in-service upgrade, and many more\cite{embedded_virtualization, KVM_on_embedded_Power}. While newer Power Architecture platforms have explicit support for efficient virtualization\cite{freescale_embedded_hyperv, hwassists_hyperv}, a majority of prevalent embedded devices run on older (and cheaper) Power Architecture platforms that use traditional trap-and-emulate style virtualization\cite{popekgoldberg}. Efficient virtualization is highly desirable on these platforms.

The current virtualization approach on Power Architecture platforms uses traditional trap-and-emulate. The guest operating system is run unprivileged, causing each execution of a privileged operation to exit into the hypervisor. For guest workloads executing a large number of privileged instructions, these VM exits are a major performance bottleneck. Table~\ref{tab:kvm_performance} lists the performance of vanilla Linux/KVM on a few common workloads, comparing them with bare-metal performance. For example, a guest Linux boot takes almost 5x longer when run virtualized.

The poor performance of simple trap-and-emulate style virtualization has led to the inclusion of paravirtual extensions in the Linux kernel on both guest and host sides for Power Architecture platform\cite{pvpower}. The paravirtual extension in the guest rewrites the guest (binary) kernel code at startup time to replace most privileged instructions with hypervisor-aware unprivileged counterparts. At guest startup, the guest creates a shared address space with the host through a hypercall. This shared address space is used by the hypervisor to store guest state information, which is accessible to the guest without incurring a trap. Table~\ref{tab:kvm_performance} lists KVM performance after enabling paravirtual extensions in the guest and the host. The performance improves significantly over unmodified KVM.

The paravirtual approach has shortcomings. Firstly, extensive guest modifications are required, which makes the optimizations highly Linux specific. Secondly, this approach cannot optimize dynamically generated/loaded code (e.g., loadable modules) because all translation is done at kernel startup time. The paravirtual approach also fails in presence of self-referential and self-modifying code in guest, as binary rewriting is done only once at startup time, and other parts of guest kernel may be unaware of this rewriting operation. The Linux guest paravirtual extensions rely on modified code not being referred or modified. These constraints are ungraceful, and hard to maintain.

We propose a host-side adaptive binary translation mechanism to optimize guest privileged instructions at runtime. Our approach is more general than the paravirtualization approach; we can optimize dynamically generated/loaded code, and can gracefully handle self- referential and self-modifying code in the guest and still achieve comparable performance to the paravirtual approach. The second-last column in Table~\ref{tab:kvm_performance} summarizes the performance results of our host-side binary translation approach. We perform our experiments on Linux/KVM running on Freescale P2020 embedded Power Architecture platform.

Our host-side virtualization optimizations are based on adaptive binary translation. On observing a large number of VM exits by a guest instruction, we translate that instruction in-place to directly execute the corresponding VMM logic (thus avoiding an exit). In doing so, we directly modify the guest’s address space. This is in contrast to a full binary translation approach that translates the entire guest code (e.g., VMware’s x86-based binary translator\cite{adams:asplos06}). Our approach is simpler and incurs less overhead than full binary translation approaches.

A major challenge with inplace guest modification is dealing with self-referential and self-modifying guest code. Since the guest address space has been modified without the guest's knowledge, the guest may refer them resulting in an undefined behavior. Also a security-conscious guest can get confused due to these changes. For example, what if the guest is performing runtime integrity checks on its code/data? Also these optimizations requires a shared space between the hypervisor and the guest to implement the VMM logic both in paravirtual extensions as well as host side optimizations. Can a malicious guest kernel/module pose a VMM security threat using this shared space ? Can we guarantee the guest's fidelity with these optimizations ?

We maintain correctness by marking pages containing the modified instructions execute-only.. The page thus protected is called a “traced page”. This causes the hardware to trap into the VMM on any guest read/write access to these traced pages. All these exits are emulated inside the hypervisor to ensure the correctness of the guest. We call this mechanism read/write tracing. This mechanisms ensures the guest's fidelity to be the same as before the optimizations.

Finally, read/write tracing can result in a large number of page faults(VM exits). In essence read/tracing intends to protect all accesses by guest on modified codes but due to constraint of page granularities, this leads in false regions being traced. The problem is exacerbated on embedded Power Architecture platform, where OS typically uses huge pages to reduce TLB pressure. We found that such page faults can significantly reduce performance. We implement two important optimizations to address this problem, namely adaptive page resizing and adaptive data mirroring.

In summary, this project presents an efficient host-side optimization solution for Power Architecture virtualization. Our approach significantly improves the performance of an unmodified guest. The scheme is based on in-place binary translation, and maintains guest correctness in presence of self-referential and self-modifying guest code.

