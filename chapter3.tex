\chapter{Read/Write Tracing}\label{ch:3}
\label{sec:memory_tracing}
Adaptive Binary Translation changes the guest address space without the guest knowledge and can cause inconsistencies if the guest tries to read or write this modified code. Thus a mechanism is to be needed in order to make sure the guest's correctness.For this reason, we need to protect the pages containing patch-sites such that whenever the guest accesses anything on these the hypervisor can provide the correct value. Also this protection mechanism should itself be oblivious to the guest to ensure guest's correctness. 

\section{Memory Management in KVM}
\label{memory_management}
In embedded power architecture platforms all modifications to tlb are privilege operations i.e any creation/deletion of a tlb entry by the guest will be trapped by the hypervisor. This mechanism allows the hypervisor to control the guest's MMU to maintain it's isolation and security. In case of KVM for embedded power architecture platforms, the hypervisor creates shadow tlb entries to insert into hardware tlb corresponding to guest tlb entries. Since the guest cannot access the shadow tlb entries directly, as all such accesses will get trapped and emulated by the hypervisor, this provides full flexibility to the hypervisor to choose the sizes and privilege level of the shadow tlb entries. For example hypervisor can use multiple tlb entries to shadow a single guest tlb entry. This mechanism is similar to the hardware-managed shadow page tables used in x86\cite{adams:asplos06}.We implement read/write tracing by disabling read/write privileges in the shadow TLB entries.

\section{Tracing}
Embedded Power Architecture platforms provide three{\tt rwx} protection bits per page for both user/supervisor privilege levels. Using these bits, we can mark a guest page containing a patch site execute-only and removes the read/write permissions from both the supervisor and user privileges. This allows the execution of an instruction on this page to proceed uninterrupted, but any read or write access causes a page fault (and a VM exit). On a page fault, the hypervisor depending on the original privileges levels of the client emulates the faulting instruction in software. We call this method memory read/write tracing (similar to VMware's memory write tracing on x86\cite{adams:asplos06}). 

We implement software emulations of memory instructions in KVM. There are 36 different memory opcodes in Power Architecture ISA that need to be emulated. For read instructions, we simply return the original contents of the memory address in the appropriate destination operand. The original contents may be obtained either from the present guest page (if the address does not intersect with a patch-site), or from the hypervisor's hash table (if the address matches a patch-site), or both. For write instructions, if the memory address (and length) intersects with a patch-site, we invalidate and free the corresponding translation cache entry and replace the guest page with it's original contents before re-executing the instruction. If the memory address does not intersect with a patch-site, we simply perform the equivalent write operation to the guest's memory. 

The overhead of read/write tracing depends on the number of accesses by the guest to its pages containing kernel code. For a Linux guest, we found that this overhead can be quite significant. Much of this overhead is due to false sharing. For example, a large number of page faults occur because guest kernel data often resides on the same page as guest kernel code. The problem becomes worse with increasing page size. Also a large page may span both the text/code section as well as the data section of the kernel resulting in every access to that data section into a VM exit. Linux on embedded Power Architecture platform uses huge pages for kernel code/data to minimize TLB pressure, causing our tracing mechanism to result in a huge number of page faults. We call these {\em tracing page faults}. 

Maintaining guest's correctness is an important aspect of the optimizations and {\tt read/write} tracing ensures the correctness of the guest's execution with binary translation optimizations to be exact as before the binary translation optimizations. Tracing may result in a large overhead due to tracing page faults and may even degrade the performance. We discuss efficient optimizations to reduce these tracing page faults in Section~\ref{ch:5}.


